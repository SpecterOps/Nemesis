apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: pubsub
spec:
  type: pubsub.rabbitmq
  version: v1
  metadata:
    - name: connectionString
      secretKeyRef:
        name: RABBITMQ_CONNECTION_STRING
        key: RABBITMQ_CONNECTION_STRING
    - name: durable
      value: "true"
    - name: deletedWhenUnused
      value: "false"
    - name: autoAck
      value: "false"
    - name: requeueInFailure
      value: "true"
    - name: reconnectWait
      value: "3"
    - name: concurrencyMode
      value: parallel
    - name: deliveryMode  # persistence setting
      value: "2"
    - name: prefetchCount # should be equal or less than the max concurrent workflows
      value: "1"
    - name: maxPriority   # set so we can prioritize some messages if wanted
      value: "3"
auth:
  secretStore: nemesis-secret-store
---
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: broadcast
spec:
  type: pubsub.rabbitmq
  version: v1
  metadata:
  - name: connectionString
    secretKeyRef:
      name: RABBITMQ_CONNECTION_STRING
      key: RABBITMQ_CONNECTION_STRING
  - name: consumerID
    value: mytest-{appID}-{uuid}    # Unique consumerID causes the message to be sent to each subscriber. Each subscriber has a RabbitMQ queue named accoridingly.
  - name: durable
    value: true
  - name: deleteWhenUnused
    value: true
  - name: autoAck
    value: true
  - name: deliveryMode
    value: 2                        # 1=transient messages(messages stay in-memory), 2=Persistent messages(use in conjunction with durable queues)
  - name: publisherConfirm
    value: true
  - name: requeueInFailure
    value: "true"
  - name: reconnectWait
    value: "3"
  - name: concurrencyMode
    value: parallel
  - name: prefetchCount # should be equal or less than the max concurrent workflows
    value: "5"
  - name: maxPriority   # set so we can prioritize some messages if wanted
    value: "3"
auth:
  secretStore: nemesis-secret-store