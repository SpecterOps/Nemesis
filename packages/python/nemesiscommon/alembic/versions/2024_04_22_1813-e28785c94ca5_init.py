"""init

Revision ID: e28785c94ca5
Revises: 
Create Date: 2024-04-22 18:13:03.419270

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'e28785c94ca5'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('api_data_messages',
    sa.Column('message_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_bytes', sa.LargeBinary(), nullable=False),
    sa.Column('expiration', sa.DateTime(), nullable=False),
    sa.PrimaryKeyConstraint('message_id'),
    comment='Messages containing data collected from agents. All incoming data POST messages sent to Nemesis are stored here in their raw form and are replayed during when/if data is reprocessed.'
    )
    op.create_table('notes',
    sa.Column('unique_db_id', sa.UUID(), nullable=False, comment='Unique DB ID of the object that has a note added'),
    sa.Column('table_name', sa.Text(), nullable=True, comment='Table name the unique_db_id originates from'),
    sa.Column('modification_time', sa.DateTime(timezone=True), nullable=True, comment='Last time the field was modified'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when the entry should be wiped from the database'),
    sa.Column('operator', sa.Text(), nullable=True, comment='Name of the operator making the change'),
    sa.Column('value', sa.Text(), nullable=True, comment='Text of the note left by an operator'),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Tracks operator notes when they triage a piece of data'
    )
    op.create_table('projects',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('name', sa.Text(), nullable=False, comment="The project's name"),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp when the project was created'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the project expires. Format: YYYY-MM-DD'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('id'),
    sa.UniqueConstraint('name'),
    comment='Project information. Each piece of ingested data is associated with a project in this table.'
    )
    op.create_table('triage',
    sa.Column('unique_db_id', sa.UUID(), nullable=False, comment='Unique DB ID of the object that has been triaged'),
    sa.Column('table_name', sa.Text(), nullable=True, comment='Table name the unique_db_id originates from'),
    sa.Column('modification_time', sa.DateTime(timezone=True), nullable=True, comment='Last time the field was modified'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when the entry should be wiped from the database'),
    sa.Column('operator', sa.Text(), nullable=True, comment='Name of the operator making the change'),
    sa.Column('value', sa.Text(), nullable=True, comment='Value indicating usefulness (Useful/Not Useful/Unknown) or not set'),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Tracks objects in the DB that have been triaged by operator input'
    )
    op.create_table('agent_host_mappings',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment="Unique row identifier for each agent_host_mapping. Each agent's host_mapping_id column will map to a single row in this table."),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the host'),
    sa.Column('host_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='ID used to collapse hosts together. Data associated with the same host should have the same host_id value and likewise differing hosts should have different host_id values.'),
    sa.Column('shortname', sa.Text(), nullable=True, comment='Short name of the host (e.g. hostname or NetBIOS name)'),
    sa.Column('longname', sa.Text(), nullable=True, comment='Long name of the host (e.g. FQDN)'),
    sa.Column('ip_address', postgresql.INET(), nullable=True, comment='IP address of the host'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('id', 'host_id'),
    sa.UniqueConstraint('id'),
    comment='Maps an agent to a host. Each agent is associated with at least a single host and potentially more if it collects data from a remote host.'
    )
    op.create_table('authentication_data',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique identifier'),
    sa.Column('agent_id', sa.Text(), nullable=False),
    sa.Column('data', sa.Text(), nullable=True),
    sa.Column('type', sa.Text(), nullable=True),
    sa.Column('is_file', sa.Boolean(), nullable=True),
    sa.Column('uri', sa.Text(), nullable=True),
    sa.Column('username', sa.Text(), nullable=True),
    sa.Column('notes', sa.Text(), nullable=True),
    sa.Column('originating_object_id', sa.UUID(), nullable=True),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Authentication data submitted to the API or surfaced by Nemesis'
    )
    op.create_table('chromium_cookies',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Chromium cookie entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('user_data_directory', sa.Text(), nullable=False, comment='Specific user Chromium data directory path, if applicable'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from user_data_directory, if applicable'),
    sa.Column('browser', sa.Text(), nullable=True, comment='Browser name extracted from user_data_directory, if applicable (Example: chrome)'),
    sa.Column('host_key', sa.Text(), nullable=False, comment='Extracted from the Chromium DB'),
    sa.Column('name', sa.Text(), nullable=False, comment='Extracted from the Chromium DB'),
    sa.Column('path', sa.Text(), nullable=False, comment='Extracted from the Chromium DB'),
    sa.Column('creation_utc', sa.DateTime(timezone=True), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('expires_utc', sa.DateTime(timezone=True), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('last_access_utc', sa.DateTime(timezone=True), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('last_update_utc', sa.DateTime(timezone=True), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('is_secure', sa.Boolean(), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('is_httponly', sa.Boolean(), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('is_session', sa.Boolean(), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('samesite', sa.Text(), nullable=True, comment='Extracted from the Chromium DB, translated from int'),
    sa.Column('source_port', sa.Integer(), nullable=True, comment='Extracted from the Chromium DB'),
    sa.Column('value_enc', sa.LargeBinary(), nullable=True, comment="Extracted from the Chromium DB 'encrypted_value' field"),
    sa.Column('encryption_type', sa.Text(), nullable=True, comment="Carved from the 'value_enc' bytes"),
    sa.Column('masterkey_guid', sa.UUID(), nullable=True, comment="If encryption_type==dpapi, linked to 'masterkey_guid' in dpapi_masterkeys"),
    sa.Column('is_decrypted', sa.Boolean(), nullable=True, comment='Is the value decrypted?'),
    sa.Column('value_dec', sa.Text(), nullable=True, comment='Decrypted value'),
    sa.Column('index_md5_hash', sa.UUID(), sa.Computed('MD5(user_data_directory || host_key || name || path)::uuid', ), nullable=False, comment='MD5 hash of the user_data_directory, host_key, name, and path. Computed to deal with length limits for the UNIQUE constraint'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'index_md5_hash', name='chromium_cookies_unique_constraint'),
    comment="Entries from the 'cookies' table in a Chromium 'Cookies' database"
    )
    op.create_table('chromium_downloads',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Chromium download entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('user_data_directory', sa.Text(), nullable=False, comment='Specific user Chromium data directory path, if applicable'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from user_data_directory, if applicable'),
    sa.Column('browser', sa.Text(), nullable=True, comment='Browser name extracted from user_data_directory, if applicable (Example: chrome)'),
    sa.Column('url', sa.Text(), nullable=True, comment="extracted from the Chromium DB 'tab_url' field"),
    sa.Column('download_path', sa.Text(), nullable=False, comment="Extracted from the Chromium DB 'target_path' field"),
    sa.Column('start_time', sa.DateTime(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('end_time', sa.DateTime(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('total_bytes', sa.Integer(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('danger_type', sa.Text(), nullable=True, comment='extracted from the Chromium DB, converted from int'),
    sa.Column('index_md5_hash', sa.UUID(), sa.Computed('MD5(user_data_directory || download_path)::uuid', ), nullable=False, comment='MD5 hash of the user_data_directory and download_path. Computed to deal with length limits for the UNIQUE constraint'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'index_md5_hash', name='chromium_downloads_url_unique_constraint'),
    comment="Entries from the 'downloads' table in a Chromium History database"
    )
    op.create_table('chromium_history',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Chromium history entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('user_data_directory', sa.Text(), nullable=True, comment='Specific user Chromium data directory path, if applicable'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from user_data_directory, if applicable'),
    sa.Column('browser', sa.Text(), nullable=True, comment='Browser name extracted from user_data_directory, if applicable (Example: chrome)'),
    sa.Column('url', sa.Text(), nullable=False, comment='URL extracted from the Chromium DB'),
    sa.Column('title', sa.Text(), nullable=False, comment='Title extracted from the Chromium DB'),
    sa.Column('visit_count', sa.Integer(), nullable=False, comment='Visit count extracted from the Chromium DB'),
    sa.Column('typed_count', sa.Integer(), nullable=False, comment='Typed count extracted from the Chromium DB'),
    sa.Column('last_visit_time', sa.DateTime(), nullable=True, comment='Last visit time extracted from the Chromium DB'),
    sa.Column('index_md5_hash', sa.UUID(), sa.Computed('MD5(user_data_directory || url)::uuid', ), nullable=False, comment='MD5 hash of the user_data_directory and url. Computed to deal with length limits for the UNIQUE constraint (URLs often exceed length limit)'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'index_md5_hash', name='chromium_history_url_unique_constraint'),
    comment="Entries from a Chromium browser's History database (stored in the 'urls' table)"
    )
    op.create_table('chromium_logins',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Chromium login entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('user_data_directory', sa.Text(), nullable=False, comment='Specific user Chromium data directory path, if applicable'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from user_data_directory, if applicable'),
    sa.Column('browser', sa.Text(), nullable=True, comment='Browser name extracted from user_data_directory, if applicable (Example: chrome)'),
    sa.Column('origin_url', sa.Text(), nullable=False, comment='extracted from the Chromium DB'),
    sa.Column('username_value', sa.Text(), nullable=False, comment='extracted from the Chromium DB'),
    sa.Column('password_value_enc', sa.LargeBinary(), nullable=True, comment="extracted from the Chromium DB 'password_value' field"),
    sa.Column('signon_realm', sa.Text(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('date_created', sa.DateTime(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('date_last_used', sa.DateTime(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('date_password_modified', sa.DateTime(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('times_used', sa.Integer(), nullable=True, comment='extracted from the Chromium DB'),
    sa.Column('encryption_type', sa.Text(), nullable=True, comment="carved from the 'password_value_enc' bytes"),
    sa.Column('masterkey_guid', sa.UUID(), nullable=True, comment="if encryption_type==dpapi, linked to 'masterkey_guid' in dpapi_masterkeys"),
    sa.Column('is_decrypted', sa.Boolean(), nullable=True, comment='Is the password decrypted?'),
    sa.Column('password_value_dec', sa.Text(), nullable=True, comment='Decrypted password value'),
    sa.Column('index_md5_hash', sa.UUID(), sa.Computed('MD5(user_data_directory || origin_url || username_value)::uuid', ), nullable=False, comment='MD5 hash of the user_data_directory, origin_url, and username_value. Computed to deal with length limits for the UNIQUE constraint'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'index_md5_hash', 'password_value_enc', name='chromium_logins_unique_constraint'),
    comment="Entries from the 'logins' table in a Chromium 'Login Data' database"
    )
    op.create_table('chromium_state_files',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Chromium state file entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('user_data_directory', sa.Text(), nullable=True, comment='Specific user Chromium data directory path, if applicable'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from user_data_directory, if applicable'),
    sa.Column('browser', sa.Text(), nullable=True, comment='Browser name extracted from user_data_directory, if applicable (Example: chrome)'),
    sa.Column('installation_date', sa.Date(), nullable=True, comment="Extracted from the Chromium 'Local State' file"),
    sa.Column('launch_count', sa.Integer(), nullable=True, comment="Extracted from the Chromium 'Local State' file"),
    sa.Column('masterkey_guid', sa.UUID(), nullable=True, comment="Linked to 'masterkey_guid' in dpapi_masterkeys"),
    sa.Column('key_bytes_enc', sa.LargeBinary(), nullable=False, comment="Extracted from the Chromium 'Local State' file"),
    sa.Column('app_bound_fixed_data_enc', sa.LargeBinary(), nullable=False, comment="Extracted from the Chromium 'Local State' file"),
    sa.Column('is_decrypted', sa.Boolean(), nullable=True, comment='Is the key decrypted?'),
    sa.Column('key_bytes_dec', sa.LargeBinary(), nullable=False, comment='Decrypted key bytes'),
    sa.Column('app_bound_fixed_data_dec', sa.LargeBinary(), nullable=False, comment='Decrypted application bound fixed data'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'user_data_directory', name='chromium_state_files_unique_constraint'),
    comment="Information/encrypted key from a Chromium 'Local State' file used to encrypt new Chromium logins/cookies"
    )
    op.create_table('dpapi_blobs',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each DPAPI blob'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('dpapi_blob_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Nemesis-assigned unique identifier for the DPAPI blob'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis UUID referencing the original file the dpapi blob was extracted from'),
    sa.Column('originating_registry_id', sa.UUID(), nullable=True, comment='Nemesis UUID referencing the registry key the dpapi blob was extracted from'),
    sa.Column('masterkey_guid', sa.UUID(), nullable=False, comment='GUID of the masterkey associated with the DPAPI blob'),
    sa.Column('is_file', sa.Boolean(), nullable=False, comment='Is the DPAPI blob associated with a Nemesis file UUID? If true, the extracted DPAPI blob too big to be stored as bytes in the DB and instead is stored as a file within Nemesis.'),
    sa.Column('is_decrypted', sa.Boolean(), nullable=False, comment='Is the DPAPI blob decrypted?'),
    sa.Column('enc_data_bytes', sa.LargeBinary(), nullable=True, comment='Bytes of the encrypted data (if less than 1024 bytes). Otherwise, use the enc_data_object_id column.'),
    sa.Column('enc_data_object_id', sa.UUID(), nullable=True, comment='If the encrypted data is > 1024 bytes, the Nemesis file UUID containing the encrypted data'),
    sa.Column('dec_data_bytes', sa.LargeBinary(), nullable=True, comment='Decrypted DPAPI blob data (if less that 1024 bytes). Otherwise, the use the dec_data_object_id column'),
    sa.Column('dec_data_object_id', sa.UUID(), nullable=True, comment='If the decrypted data is > 1024 bytes, the Nemesis file UUID containing the decrytped data'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.CheckConstraint('(is_decrypted = False AND (dec_data_bytes IS NULL AND dec_data_object_id IS NULL)) OR (is_decrypted = True AND (dec_data_bytes IS NOT NULL OR dec_data_object_id IS NOT NULL))', name='dpapi_blobs_check_dec_data_presence_if_decrypted'),
    sa.CheckConstraint('(is_file = False AND enc_data_bytes IS NOT NULL AND enc_data_object_id IS NULL AND dec_data_object_id IS NULL) OR (is_file = True AND enc_data_bytes IS NULL AND enc_data_object_id IS NOT NULL AND dec_data_bytes IS NULL)', name='dpapi_blobs_check_enc_dec_data_consistency'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('dpapi_blob_id'),
    comment='Contains extracted DPAPI blobs in their encrypted and/or decrypted forms.'
    )
    op.create_table('dpapi_domain_backupkeys',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each DPAPI blob'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('domain_backupkey_guid', sa.UUID(), nullable=False, comment='GUID of the domain backup key. Linked to dpapi_masterkeys.domain_backupkey_guid'),
    sa.Column('domain_controller', sa.Text(), nullable=False, comment='Domain controller from which the backup key was extracted'),
    sa.Column('domain_backupkey_bytes', sa.LargeBinary(), nullable=False, comment="Bytes of the domain's DPAPI backup private key"),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('domain_backupkey_guid'),
    comment='Contains extracted DPAPI domain backup keys.'
    )
    op.create_table('dpapi_masterkeys',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each DPAPI blob'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID of the master key'),
    sa.Column('type', sa.Text(), nullable=True, comment='Type of user the master key belongs to (domain_user, local_user, or machine)'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username of the user who owns the master key'),
    sa.Column('user_sid', sa.Text(), nullable=True, comment='Security Identifier(SID) of the user who owns the master key'),
    sa.Column('masterkey_guid', sa.UUID(), nullable=False, comment='GUID of the master key. If a blob can be decrypted, dpapi_blobs.masterkey_guid should match this value.'),
    sa.Column('is_decrypted', sa.Boolean(), nullable=True, comment='Is the master key decrypted?'),
    sa.Column('masterkey_bytes', sa.LargeBinary(), nullable=True, comment='Bytes of the master key'),
    sa.Column('domain_backupkey_guid', sa.UUID(), nullable=True, comment='GUID of the domain backup key. Linked to dpapi_domain_backupkeys.domain_backupkey_guid'),
    sa.Column('domainkey_pb_secret', sa.LargeBinary(), nullable=True, comment='Encrypted master key. Associated domain backup key can decrypt this.'),
    sa.Column('decrypted_key_full', sa.LargeBinary(), nullable=True, comment='Decrypted master key'),
    sa.Column('decrypted_key_sha1', sa.LargeBinary(), nullable=True, comment='SHA1 representation of the master key'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('masterkey_guid'),
    comment='Contains individual extracted DPAPI master keys.'
    )
    op.create_table('extracted_hashes',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique identifier'),
    sa.Column('agent_id', sa.Text(), nullable=False),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if the hash was carved from a file'),
    sa.Column('hash_type', sa.Text(), nullable=True, comment='Type of hash'),
    sa.Column('hash_value', sa.Text(), nullable=False, comment='Value of the extracted hash'),
    sa.Column('hashcat_formatted_value', sa.Text(), nullable=True, comment='Hashcat-formatted hash value'),
    sa.Column('jtr_formatted_value', sa.Text(), nullable=True, comment='JTR-formatted hash value'),
    sa.Column('is_cracked', sa.Boolean(), nullable=True, comment='True if the hash has been cracked'),
    sa.Column('checked_against_top_passwords', sa.Boolean(), nullable=True, comment='True if checked against top passwords'),
    sa.Column('is_submitted_to_cracker', sa.Boolean(), nullable=True, comment='True if submitted to a cracker'),
    sa.Column('cracker_submission_time', sa.DateTime(timezone=True), nullable=True, comment='Time the hash was submitted to a cracker'),
    sa.Column('cracker_cracked_time', sa.DateTime(timezone=True), nullable=True, comment='Time the hash was cracked'),
    sa.Column('plaintext_value', sa.Text(), nullable=True, comment='Plaintext value if the hash has been cracked'),
    sa.Column('hash_value_md5_hash', sa.UUID(), sa.Computed('MD5(hash_value)::uuid', ), nullable=False, comment='MD5 hash of the hash value. Used in the unique constraint due to hashes potentially being too long for constraints'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('timestamp', 'originating_object_id', 'hash_value_md5_hash', name='extracted_hashes_unique_constraint'),
    comment='Extracted hashes from various sources (e.g., encrypted files/documents)'
    )
    op.create_table('hosts_deprecated',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique identifier'),
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('hostname', sa.Text(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('os_type', sa.Text(), nullable=True),
    sa.Column('windows_major_version', sa.Numeric(precision=9, scale=1), nullable=True),
    sa.Column('windows_build', sa.Text(), nullable=True),
    sa.Column('windows_release', sa.Text(), nullable=True),
    sa.Column('windows_domain', sa.Text(), nullable=True),
    sa.Column('linux_kernel_version', sa.Text(), nullable=True),
    sa.Column('linux_distributor', sa.Text(), nullable=True),
    sa.Column('linux_release', sa.Text(), nullable=True),
    sa.Column('agent_ids', sa.ARRAY(sa.Text()), nullable=True),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('hostname', name='hosts_unique_constraint')
    )
    op.create_table('slack_downloads',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Slack download entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=False, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from file path, if applicable'),
    sa.Column('workspace_id', sa.Text(), nullable=False, comment='Extracted from slack-downloads'),
    sa.Column('download_id', sa.Text(), nullable=False, comment='Extracted from slack-downloads'),
    sa.Column('team_id', sa.Text(), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('user_id', sa.Text(), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('url', sa.Text(), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('download_path', sa.Text(), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('download_state', sa.Text(), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('start_time', sa.DateTime(timezone=True), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('end_time', sa.DateTime(timezone=True), nullable=True, comment='Extracted from slack-downloads'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'workspace_id', 'download_id', name='slack_downloads_unique_constraint'),
    comment="Parsed downloads from a 'slack-downloads' file or Seatbelt json"
    )
    op.create_table('slack_workspaces',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each Slack download entry'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Nemesis file UUID if this entry originated from a file'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username extracted from file path, if applicable'),
    sa.Column('workspace_id', sa.Text(), nullable=True, comment='Extracted from slack-workspaces'),
    sa.Column('workspace_domain', sa.Text(), nullable=True, comment='Extracted from slack-workspaces'),
    sa.Column('workspace_name', sa.Text(), nullable=True, comment='Extracted from slack-workspaces'),
    sa.Column('workspace_icon_url', sa.Text(), nullable=True, comment='Extracted from slack-workspaces'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('source', 'agent_id', 'originating_object_id', 'workspace_id', 'workspace_domain', 'workspace_name', name='slack_workspaces_unique_constraint'),
    comment="Parsed workspaces from a 'slack-workspaces' file or Seatbelt json"
    )
    op.create_table('agents',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique row identifier for each agent'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the agent'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)'),
    sa.Column('agent_type', sa.Text(), nullable=False, comment='String describing the type of agent (beacon, apollo, stage1, etc.)'),
    sa.Column('host_mapping_id', sa.UUID(), nullable=False, comment='Points to the host mapping for agent. For each agent, there is a single agent_host_mappings row that maps it to a host (i.e., there is a 1:1 relationship between agents and agent host mappings)'),
    sa.ForeignKeyConstraint(['host_mapping_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('agent_id', 'agent_type', 'project_id', name='agents_agent_id_agent_type_project_id_key'),
    sa.UniqueConstraint('host_mapping_id'),
    sa.UniqueConstraint('id'),
    comment='Basic information surfaced about collection agents that have submitted data'
    )
    op.create_table('agents_deprecated',
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False, comment='Unique identifier'),
    sa.Column('agent_id', sa.Text(), nullable=False, comment='ID from Cobalt Strike/Mythic/etc.'),
    sa.Column('host_id', sa.Integer(), nullable=True, comment='Reference to host the agent is running on'),
    sa.Column('agent_type', sa.Text(), nullable=False, comment='Type of the agent'),
    sa.Column('first_seen', sa.DateTime(timezone=True), nullable=True, comment='Timestamp when the agent was first seen'),
    sa.Column('last_seen', sa.DateTime(timezone=True), nullable=True, comment='Timestamp when the agent was last seen'),
    sa.Column('is_alive', sa.Boolean(), nullable=True, comment='True if the agent is currently alive'),
    sa.Column('arch', sa.Text(), nullable=True, comment="Architecture of the agent's system"),
    sa.Column('process_name', sa.Text(), nullable=True, comment='Name of the process the agent is running as'),
    sa.Column('process_id', sa.Integer(), nullable=True, comment='Process ID of the agent process'),
    sa.Column('process_username', sa.Text(), nullable=True, comment='Username under which the agent process is running'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('source', sa.Text(), nullable=False, comment='Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.ForeignKeyConstraint(['host_id'], ['hosts_deprecated.id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('agent_id'),
    sa.UniqueConstraint('agent_id', 'agent_type', name='agents_unique_constraint'),
    comment='Tracks agents that have connected to the server'
    )
    op.create_table('file_data_enriched',
    sa.Column('object_id', sa.UUID(), nullable=False, comment='Nemesis file UUID of the file'),
    sa.Column('path', sa.Text(), nullable=False, comment="The file's path"),
    sa.Column('name', sa.Text(), nullable=True, comment="The file's name"),
    sa.Column('size', sa.BigInteger(), nullable=True, comment='Size of the file in bytes'),
    sa.Column('md5', sa.Text(), nullable=True, comment='MD5 hash of the file'),
    sa.Column('sha1', sa.Text(), nullable=True, comment='SHA1 hash of the file'),
    sa.Column('sha256', sa.Text(), nullable=True, comment='SHA256 hash of the file'),
    sa.Column('nemesis_file_type', sa.Text(), nullable=True, comment='Nemesis-derived file type'),
    sa.Column('magic_type', sa.Text(), nullable=True, comment="Magic type of the file (derived from sniffing the file's content via libmagic)"),
    sa.Column('converted_pdf_id', sa.UUID(), nullable=True, comment="Nemesis file UUID if there's a converted PDF linked to this file"),
    sa.Column('extracted_plaintext_id', sa.UUID(), nullable=True, comment="Nemesis file UUID if there's extracted plaintext linked to this file"),
    sa.Column('extracted_source_id', sa.UUID(), nullable=True, comment="Nemesis file UUID if there's extracted source code linked to this file"),
    sa.Column('tags', sa.ARRAY(sa.Text()), nullable=True, comment='List of tags associated with the file (e.g., hash_dpapi, has_deserialization, etc.)'),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    sa.UniqueConstraint('object_id'),
    comment='An in-between the Elastic and Postgres representations for enriched data. This is for ease of use of searching/filtering through the dashboard(s)'
    )
    op.create_table('filesystem_objects',
    sa.Column('path', sa.Text(), nullable=False, comment='Path to the file or folder'),
    sa.Column('name', sa.Text(), nullable=True, comment='Name of the file or folder'),
    sa.Column('extension', sa.Text(), nullable=True, comment='File extension'),
    sa.Column('type', sa.Enum('file', 'folder', name='filesystemobjecttype'), nullable=False, comment='Type of object: file or folder'),
    sa.Column('size', sa.Integer(), nullable=True, comment='Size of the file in bytes'),
    sa.Column('magic_type', sa.Text(), nullable=True, comment="Type of the file (derived from sniffing the file's content)"),
    sa.Column('creation_time', sa.DateTime(), nullable=True, comment='Time the file was created'),
    sa.Column('access_time', sa.DateTime(), nullable=True, comment='Time the file was last accessed'),
    sa.Column('modification_time', sa.DateTime(), nullable=True, comment='Time the file was last modified'),
    sa.Column('access_mode', sa.Integer(), nullable=True, comment='File access mode (*nix permission number)'),
    sa.Column('file_group', sa.Text(), nullable=True, comment='File group (*nix case sensitive file group membership)'),
    sa.Column('file_id', sa.Text(), nullable=True, comment='File ID (*nix string for an inode or file id)'),
    sa.Column('owner', sa.Text(), nullable=True, comment='Case sensitive owner (*nix and Windows)'),
    sa.Column('sddl', sa.Text(), nullable=True, comment='Security Descriptor Definition Language (SDDL) string'),
    sa.Column('nemesis_file_id', sa.UUID(), nullable=True, comment='Nemesis-assigned unique identifier for the file'),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Filesystem objects (files and folders) collected from a host, whether through downloads or listings.'
    )
    op.create_index('filesystem_objects_on_path_idx', 'filesystem_objects', ['path'], unique=False, postgresql_using='gin', postgresql_ops={'path': 'gin_trgm_ops'})
    op.create_table('named_pipes',
    sa.Column('name', sa.Text(), nullable=False, comment="The pipe's name"),
    sa.Column('server_process_id', sa.Integer(), nullable=True, comment='Process ID that created the pipe'),
    sa.Column('server_process_name', sa.Text(), nullable=True, comment='Name of the process that created the pipe'),
    sa.Column('server_process_path', sa.Text(), nullable=True, comment='Full path to the process that created the pipe'),
    sa.Column('server_process_session_id', sa.Integer(), nullable=True, comment='Session ID of the process that created the pipe'),
    sa.Column('sddl', sa.Text(), nullable=True, comment='Security Descriptor Definition Language (SDDL) string for the pipe'),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Windows named pipes, derived Seatbelt data or submitted manually'
    )
    op.create_table('processes',
    sa.Column('name', sa.Text(), nullable=True, comment="The process's name"),
    sa.Column('command_line', sa.Text(), nullable=True, comment="A process's command line"),
    sa.Column('file_name', sa.Text(), nullable=True, comment='Path to the file'),
    sa.Column('process_id', sa.Integer(), nullable=True, comment='Process ID'),
    sa.Column('parent_process_id', sa.Integer(), nullable=True, comment="Parent process's PID"),
    sa.Column('architecture', sa.Text(), nullable=True, comment="Process's architecture"),
    sa.Column('username', sa.Text(), nullable=True, comment="The process's username"),
    sa.Column('category', sa.Text(), nullable=True, comment='Enriched category of the process'),
    sa.Column('description', sa.Text(), nullable=True, comment="Enriched category's description"),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.CheckConstraint("(name IS NOT NULL AND name <> '') OR process_id IS NOT NULL"),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Represents a process running on a host. At a minimum, a process needs a name and/or process ID.'
    )
    op.create_table('registry_objects',
    sa.Column('key', sa.Text(), nullable=False, comment='Registry key'),
    sa.Column('value_name', sa.Text(), nullable=True, comment='Name of the registry value'),
    sa.Column('value_kind', sa.Integer(), nullable=True, comment="The registry value's data type"),
    sa.Column('value', sa.Text(), nullable=True, comment='Content of the registry value'),
    sa.Column('sddl', sa.Text(), nullable=True, comment='Security Descriptor Definition Language (SDDL) string for the registry object'),
    sa.Column('tags', sa.Text(), nullable=True, comment='Tags associated with the registry object'),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Registry entry objects'
    )
    op.create_table('services',
    sa.Column('binary_path', sa.Text(), nullable=True, comment="Filesystem path to the service's binary"),
    sa.Column('command_line', sa.Text(), nullable=True, comment='Command line used to start the service'),
    sa.Column('description', sa.Text(), nullable=True, comment='Description of the service'),
    sa.Column('display_name', sa.Text(), nullable=True, comment='Display name of the service'),
    sa.Column('name', sa.Text(), nullable=False, comment='Name of the service'),
    sa.Column('sddl', sa.Text(), nullable=True, comment='Security Descriptor Definition Language (SDDL) string for the service'),
    sa.Column('service_dll_entrypoint', sa.Text(), nullable=True, comment='Entrypoint function name in the service DLL'),
    sa.Column('service_dll_path', sa.Text(), nullable=True, comment='Filesystem path to the service DLL'),
    sa.Column('service_type', sa.SmallInteger(), nullable=True, comment='Type of the service'),
    sa.Column('start_type', sa.SmallInteger(), nullable=True, comment='How the service starts'),
    sa.Column('state', sa.SmallInteger(), nullable=True, comment='Current state of the service'),
    sa.Column('username', sa.Text(), nullable=True, comment='Username under which the service runs'),
    sa.Column('filesystem_object_id', sa.UUID(), nullable=True, comment="Reference to the service file if it's been downloaded"),
    sa.Column('host_id', sa.UUID(), nullable=False, comment='Identifies the host the data is currently mapped to'),
    sa.Column('is_data_remote', sa.Boolean(), nullable=False, comment='Is the data for a remote host? Or was it enumerated locally on the current machine?'),
    sa.Column('operation', sa.Enum('list', 'add', 'remove', name='dataoperation'), nullable=False, comment='Type of operation: list, add, or remove'),
    sa.Column('unique_db_id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False, comment='Original message ID assigned during data ingestion'),
    sa.Column('project_id', sa.UUID(), nullable=False, comment='Project associated with the data'),
    sa.Column('timestamp', sa.DateTime(), nullable=False, comment='Timestamp of when the data was created/collected.'),
    sa.Column('expiration', sa.Date(), nullable=False, comment='Date when in the data expires. Format: YYYY-MM-DD'),
    sa.Column('agent_id', sa.UUID(), nullable=False, comment='ID of the agent that collected the data'),
    sa.Column('originating_object_id', sa.UUID(), nullable=True, comment='Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.'),
    sa.ForeignKeyConstraint(['agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['filesystem_object_id'], ['filesystem_objects.unique_db_id'], ),
    sa.ForeignKeyConstraint(['host_id'], ['agent_host_mappings.id'], ),
    sa.ForeignKeyConstraint(['message_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['originating_object_id'], ['api_data_messages.message_id'], ),
    sa.ForeignKeyConstraint(['project_id'], ['projects.id'], ),
    sa.PrimaryKeyConstraint('unique_db_id'),
    comment='Windows services, derived from registry values or submitted manually'
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('services')
    op.drop_table('registry_objects')
    op.drop_table('processes')
    op.drop_table('named_pipes')
    op.drop_index('filesystem_objects_on_path_idx', table_name='filesystem_objects', postgresql_using='gin', postgresql_ops={'path': 'gin_trgm_ops'})
    op.drop_table('filesystem_objects')
    op.drop_table('file_data_enriched')
    op.drop_table('agents_deprecated')
    op.drop_table('agents')
    op.drop_table('slack_workspaces')
    op.drop_table('slack_downloads')
    op.drop_table('hosts_deprecated')
    op.drop_table('extracted_hashes')
    op.drop_table('dpapi_masterkeys')
    op.drop_table('dpapi_domain_backupkeys')
    op.drop_table('dpapi_blobs')
    op.drop_table('chromium_state_files')
    op.drop_table('chromium_logins')
    op.drop_table('chromium_history')
    op.drop_table('chromium_downloads')
    op.drop_table('chromium_cookies')
    op.drop_table('authentication_data')
    op.drop_table('agent_host_mappings')
    op.drop_table('triage')
    op.drop_table('projects')
    op.drop_table('notes')
    op.drop_table('api_data_messages')
    # ### end Alembic commands ###
