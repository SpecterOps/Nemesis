apiVersion: v1
kind: ConfigMap
metadata:
    name: postgres-nemesis-schema
    labels:
        app: postgres-nemesis-schema
data:
    nemesis.sql: |
        DROP SCHEMA IF EXISTS "nemesis" CASCADE;
        CREATE SCHEMA "nemesis";
        SET search_path TO "nemesis";

        -- used for index processing for file trees
        CREATE EXTENSION IF NOT EXISTS pg_trgm;

        START TRANSACTION;
        SET TIME ZONE 'UTC';
        CREATE SCHEMA IF NOT EXISTS nemesis;

        
        -- Tables


        CREATE TABLE alembic_version (
            version_num VARCHAR(32) NOT NULL, 
            CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
        );

        -- Running upgrade  -> e28785c94ca5

        CREATE TABLE api_data_messages (
            message_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_bytes BYTEA NOT NULL, 
            expiration TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            PRIMARY KEY (message_id)
        );

        COMMENT ON TABLE api_data_messages IS 'Messages containing data collected from agents. All incoming data POST messages sent to Nemesis are stored here in their raw form and are replayed during when/if data is reprocessed.';

        CREATE TABLE notes (
            unique_db_id UUID NOT NULL, 
            table_name TEXT, 
            modification_time TIMESTAMP WITH TIME ZONE, 
            expiration DATE NOT NULL, 
            operator TEXT, 
            value TEXT, 
            PRIMARY KEY (unique_db_id)
        );

        COMMENT ON TABLE notes IS 'Tracks operator notes when they triage a piece of data';

        COMMENT ON COLUMN notes.unique_db_id IS 'Unique DB ID of the object that has a note added';

        COMMENT ON COLUMN notes.table_name IS 'Table name the unique_db_id originates from';

        COMMENT ON COLUMN notes.modification_time IS 'Last time the field was modified';

        COMMENT ON COLUMN notes.expiration IS 'Date when the entry should be wiped from the database';

        COMMENT ON COLUMN notes.operator IS 'Name of the operator making the change';

        COMMENT ON COLUMN notes.value IS 'Text of the note left by an operator';

        CREATE TABLE projects (
            id UUID DEFAULT gen_random_uuid() NOT NULL, 
            name TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (id), 
            UNIQUE (id), 
            UNIQUE (name)
        );

        COMMENT ON TABLE projects IS 'Project information. Each piece of ingested data is associated with a project in this table.';

        COMMENT ON COLUMN projects.name IS 'The project''s name';

        COMMENT ON COLUMN projects.timestamp IS 'Timestamp when the project was created';

        COMMENT ON COLUMN projects.expiration IS 'Date when in the project expires. Format: YYYY-MM-DD';

        CREATE TABLE triage (
            unique_db_id UUID NOT NULL, 
            table_name TEXT, 
            modification_time TIMESTAMP WITH TIME ZONE, 
            expiration DATE NOT NULL, 
            operator TEXT, 
            value TEXT, 
            PRIMARY KEY (unique_db_id)
        );

        COMMENT ON TABLE triage IS 'Tracks objects in the DB that have been triaged by operator input';

        COMMENT ON COLUMN triage.unique_db_id IS 'Unique DB ID of the object that has been triaged';

        COMMENT ON COLUMN triage.table_name IS 'Table name the unique_db_id originates from';

        COMMENT ON COLUMN triage.modification_time IS 'Last time the field was modified';

        COMMENT ON COLUMN triage.expiration IS 'Date when the entry should be wiped from the database';

        COMMENT ON COLUMN triage.operator IS 'Name of the operator making the change';

        COMMENT ON COLUMN triage.value IS 'Value indicating usefulness (Useful/Not Useful/Unknown) or not set';

        CREATE TABLE agent_host_mappings (
            id UUID DEFAULT gen_random_uuid() NOT NULL, 
            project_id UUID NOT NULL, 
            host_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            shortname TEXT, 
            longname TEXT, 
            ip_address INET, 
            PRIMARY KEY (id, host_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            UNIQUE (id)
        );

        COMMENT ON TABLE agent_host_mappings IS 'Maps an agent to a host. Each agent is associated with at least a single host and potentially more if it collects data from a remote host.';

        COMMENT ON COLUMN agent_host_mappings.id IS 'Unique row identifier for each agent_host_mapping. Each agent''s host_mapping_id column will map to a single row in this table.';

        COMMENT ON COLUMN agent_host_mappings.project_id IS 'Project associated with the host';

        COMMENT ON COLUMN agent_host_mappings.host_id IS 'ID used to collapse hosts together. Data associated with the same host should have the same host_id value and likewise differing hosts should have different host_id values.';

        COMMENT ON COLUMN agent_host_mappings.shortname IS 'Short name of the host (e.g. hostname or NetBIOS name)';

        COMMENT ON COLUMN agent_host_mappings.longname IS 'Long name of the host (e.g. FQDN)';

        COMMENT ON COLUMN agent_host_mappings.ip_address IS 'IP address of the host';

        CREATE TABLE authentication_data (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            data TEXT, 
            type TEXT, 
            is_file BOOLEAN, 
            uri TEXT, 
            username TEXT, 
            notes TEXT, 
            originating_object_id UUID, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE authentication_data IS 'Authentication data submitted to the API or surfaced by Nemesis';

        COMMENT ON COLUMN authentication_data.unique_db_id IS 'Unique identifier';

        COMMENT ON COLUMN authentication_data.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN authentication_data.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN authentication_data.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN authentication_data.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE chromium_cookies (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            user_data_directory TEXT NOT NULL, 
            username TEXT, 
            browser TEXT, 
            host_key TEXT NOT NULL, 
            name TEXT NOT NULL, 
            path TEXT NOT NULL, 
            creation_utc TIMESTAMP WITH TIME ZONE, 
            expires_utc TIMESTAMP WITH TIME ZONE, 
            last_access_utc TIMESTAMP WITH TIME ZONE, 
            last_update_utc TIMESTAMP WITH TIME ZONE, 
            is_secure BOOLEAN, 
            is_httponly BOOLEAN, 
            is_session BOOLEAN, 
            samesite TEXT, 
            source_port INTEGER, 
            value_enc BYTEA, 
            encryption_type TEXT, 
            masterkey_guid UUID, 
            is_decrypted BOOLEAN, 
            value_dec TEXT, 
            index_md5_hash UUID GENERATED ALWAYS AS (MD5(user_data_directory || host_key || name || path)::uuid) STORED NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT chromium_cookies_unique_constraint UNIQUE (source, agent_id, originating_object_id, index_md5_hash)
        );

        COMMENT ON TABLE chromium_cookies IS 'Entries from the ''cookies'' table in a Chromium ''Cookies'' database';

        COMMENT ON COLUMN chromium_cookies.unique_db_id IS 'Unique row identifier for each Chromium cookie entry';

        COMMENT ON COLUMN chromium_cookies.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN chromium_cookies.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN chromium_cookies.user_data_directory IS 'Specific user Chromium data directory path, if applicable';

        COMMENT ON COLUMN chromium_cookies.username IS 'Username extracted from user_data_directory, if applicable';

        COMMENT ON COLUMN chromium_cookies.browser IS 'Browser name extracted from user_data_directory, if applicable (Example: chrome)';

        COMMENT ON COLUMN chromium_cookies.host_key IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.name IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.path IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.creation_utc IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.expires_utc IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.last_access_utc IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.last_update_utc IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.is_secure IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.is_httponly IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.is_session IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.samesite IS 'Extracted from the Chromium DB, translated from int';

        COMMENT ON COLUMN chromium_cookies.source_port IS 'Extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_cookies.value_enc IS 'Extracted from the Chromium DB ''encrypted_value'' field';

        COMMENT ON COLUMN chromium_cookies.encryption_type IS 'Carved from the ''value_enc'' bytes';

        COMMENT ON COLUMN chromium_cookies.masterkey_guid IS 'If encryption_type==dpapi, linked to ''masterkey_guid'' in dpapi_masterkeys';

        COMMENT ON COLUMN chromium_cookies.is_decrypted IS 'Is the value decrypted?';

        COMMENT ON COLUMN chromium_cookies.value_dec IS 'Decrypted value';

        COMMENT ON COLUMN chromium_cookies.index_md5_hash IS 'MD5 hash of the user_data_directory, host_key, name, and path. Computed to deal with length limits for the UNIQUE constraint';

        COMMENT ON COLUMN chromium_cookies.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN chromium_cookies.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN chromium_cookies.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN chromium_cookies.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE chromium_downloads (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            user_data_directory TEXT NOT NULL, 
            username TEXT, 
            browser TEXT, 
            url TEXT, 
            download_path TEXT NOT NULL, 
            start_time TIMESTAMP WITHOUT TIME ZONE, 
            end_time TIMESTAMP WITHOUT TIME ZONE, 
            total_bytes INTEGER, 
            danger_type TEXT, 
            index_md5_hash UUID GENERATED ALWAYS AS (MD5(user_data_directory || download_path)::uuid) STORED NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT chromium_downloads_url_unique_constraint UNIQUE (source, agent_id, originating_object_id, index_md5_hash)
        );

        COMMENT ON TABLE chromium_downloads IS 'Entries from the ''downloads'' table in a Chromium History database';

        COMMENT ON COLUMN chromium_downloads.unique_db_id IS 'Unique row identifier for each Chromium download entry';

        COMMENT ON COLUMN chromium_downloads.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN chromium_downloads.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN chromium_downloads.user_data_directory IS 'Specific user Chromium data directory path, if applicable';

        COMMENT ON COLUMN chromium_downloads.username IS 'Username extracted from user_data_directory, if applicable';

        COMMENT ON COLUMN chromium_downloads.browser IS 'Browser name extracted from user_data_directory, if applicable (Example: chrome)';

        COMMENT ON COLUMN chromium_downloads.url IS 'extracted from the Chromium DB ''tab_url'' field';

        COMMENT ON COLUMN chromium_downloads.download_path IS 'Extracted from the Chromium DB ''target_path'' field';

        COMMENT ON COLUMN chromium_downloads.start_time IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_downloads.end_time IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_downloads.total_bytes IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_downloads.danger_type IS 'extracted from the Chromium DB, converted from int';

        COMMENT ON COLUMN chromium_downloads.index_md5_hash IS 'MD5 hash of the user_data_directory and download_path. Computed to deal with length limits for the UNIQUE constraint';

        COMMENT ON COLUMN chromium_downloads.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN chromium_downloads.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN chromium_downloads.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN chromium_downloads.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE chromium_history (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            user_data_directory TEXT, 
            username TEXT, 
            browser TEXT, 
            url TEXT NOT NULL, 
            title TEXT NOT NULL, 
            visit_count INTEGER NOT NULL, 
            typed_count INTEGER NOT NULL, 
            last_visit_time TIMESTAMP WITHOUT TIME ZONE, 
            index_md5_hash UUID GENERATED ALWAYS AS (MD5(user_data_directory || url)::uuid) STORED NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT chromium_history_url_unique_constraint UNIQUE (source, agent_id, originating_object_id, index_md5_hash)
        );

        COMMENT ON TABLE chromium_history IS 'Entries from a Chromium browser''s History database (stored in the ''urls'' table)';

        COMMENT ON COLUMN chromium_history.unique_db_id IS 'Unique row identifier for each Chromium history entry';

        COMMENT ON COLUMN chromium_history.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN chromium_history.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN chromium_history.user_data_directory IS 'Specific user Chromium data directory path, if applicable';

        COMMENT ON COLUMN chromium_history.username IS 'Username extracted from user_data_directory, if applicable';

        COMMENT ON COLUMN chromium_history.browser IS 'Browser name extracted from user_data_directory, if applicable (Example: chrome)';

        COMMENT ON COLUMN chromium_history.url IS 'URL extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_history.title IS 'Title extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_history.visit_count IS 'Visit count extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_history.typed_count IS 'Typed count extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_history.last_visit_time IS 'Last visit time extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_history.index_md5_hash IS 'MD5 hash of the user_data_directory and url. Computed to deal with length limits for the UNIQUE constraint (URLs often exceed length limit)';

        COMMENT ON COLUMN chromium_history.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN chromium_history.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN chromium_history.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN chromium_history.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE chromium_logins (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            user_data_directory TEXT NOT NULL, 
            username TEXT, 
            browser TEXT, 
            origin_url TEXT NOT NULL, 
            username_value TEXT NOT NULL, 
            password_value_enc BYTEA, 
            signon_realm TEXT, 
            date_created TIMESTAMP WITHOUT TIME ZONE, 
            date_last_used TIMESTAMP WITHOUT TIME ZONE, 
            date_password_modified TIMESTAMP WITHOUT TIME ZONE, 
            times_used INTEGER, 
            encryption_type TEXT, 
            masterkey_guid UUID, 
            is_decrypted BOOLEAN, 
            password_value_dec TEXT, 
            index_md5_hash UUID GENERATED ALWAYS AS (MD5(user_data_directory || origin_url || username_value)::uuid) STORED NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT chromium_logins_unique_constraint UNIQUE (source, agent_id, originating_object_id, index_md5_hash, password_value_enc)
        );

        COMMENT ON TABLE chromium_logins IS 'Entries from the ''logins'' table in a Chromium ''Login Data'' database';

        COMMENT ON COLUMN chromium_logins.unique_db_id IS 'Unique row identifier for each Chromium login entry';

        COMMENT ON COLUMN chromium_logins.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN chromium_logins.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN chromium_logins.user_data_directory IS 'Specific user Chromium data directory path, if applicable';

        COMMENT ON COLUMN chromium_logins.username IS 'Username extracted from user_data_directory, if applicable';

        COMMENT ON COLUMN chromium_logins.browser IS 'Browser name extracted from user_data_directory, if applicable (Example: chrome)';

        COMMENT ON COLUMN chromium_logins.origin_url IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.username_value IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.password_value_enc IS 'extracted from the Chromium DB ''password_value'' field';

        COMMENT ON COLUMN chromium_logins.signon_realm IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.date_created IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.date_last_used IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.date_password_modified IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.times_used IS 'extracted from the Chromium DB';

        COMMENT ON COLUMN chromium_logins.encryption_type IS 'carved from the ''password_value_enc'' bytes';

        COMMENT ON COLUMN chromium_logins.masterkey_guid IS 'if encryption_type==dpapi, linked to ''masterkey_guid'' in dpapi_masterkeys';

        COMMENT ON COLUMN chromium_logins.is_decrypted IS 'Is the password decrypted?';

        COMMENT ON COLUMN chromium_logins.password_value_dec IS 'Decrypted password value';

        COMMENT ON COLUMN chromium_logins.index_md5_hash IS 'MD5 hash of the user_data_directory, origin_url, and username_value. Computed to deal with length limits for the UNIQUE constraint';

        COMMENT ON COLUMN chromium_logins.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN chromium_logins.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN chromium_logins.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN chromium_logins.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE chromium_state_files (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            user_data_directory TEXT, 
            username TEXT, 
            browser TEXT, 
            installation_date DATE, 
            launch_count INTEGER, 
            masterkey_guid UUID, 
            key_bytes_enc BYTEA NOT NULL, 
            app_bound_fixed_data_enc BYTEA NOT NULL, 
            is_decrypted BOOLEAN, 
            key_bytes_dec BYTEA NOT NULL, 
            app_bound_fixed_data_dec BYTEA NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT chromium_state_files_unique_constraint UNIQUE (source, agent_id, originating_object_id, user_data_directory)
        );

        COMMENT ON TABLE chromium_state_files IS 'Information/encrypted key from a Chromium ''Local State'' file used to encrypt new Chromium logins/cookies';

        COMMENT ON COLUMN chromium_state_files.unique_db_id IS 'Unique row identifier for each Chromium state file entry';

        COMMENT ON COLUMN chromium_state_files.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN chromium_state_files.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN chromium_state_files.user_data_directory IS 'Specific user Chromium data directory path, if applicable';

        COMMENT ON COLUMN chromium_state_files.username IS 'Username extracted from user_data_directory, if applicable';

        COMMENT ON COLUMN chromium_state_files.browser IS 'Browser name extracted from user_data_directory, if applicable (Example: chrome)';

        COMMENT ON COLUMN chromium_state_files.installation_date IS 'Extracted from the Chromium ''Local State'' file';

        COMMENT ON COLUMN chromium_state_files.launch_count IS 'Extracted from the Chromium ''Local State'' file';

        COMMENT ON COLUMN chromium_state_files.masterkey_guid IS 'Linked to ''masterkey_guid'' in dpapi_masterkeys';

        COMMENT ON COLUMN chromium_state_files.key_bytes_enc IS 'Extracted from the Chromium ''Local State'' file';

        COMMENT ON COLUMN chromium_state_files.app_bound_fixed_data_enc IS 'Extracted from the Chromium ''Local State'' file';

        COMMENT ON COLUMN chromium_state_files.is_decrypted IS 'Is the key decrypted?';

        COMMENT ON COLUMN chromium_state_files.key_bytes_dec IS 'Decrypted key bytes';

        COMMENT ON COLUMN chromium_state_files.app_bound_fixed_data_dec IS 'Decrypted application bound fixed data';

        COMMENT ON COLUMN chromium_state_files.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN chromium_state_files.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN chromium_state_files.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN chromium_state_files.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE dpapi_blobs (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            dpapi_blob_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            originating_object_id UUID, 
            originating_registry_id UUID, 
            masterkey_guid UUID NOT NULL, 
            is_file BOOLEAN NOT NULL, 
            is_decrypted BOOLEAN NOT NULL, 
            enc_data_bytes BYTEA, 
            enc_data_object_id UUID, 
            dec_data_bytes BYTEA, 
            dec_data_object_id UUID, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (dpapi_blob_id), 
            CONSTRAINT dpapi_blobs_check_dec_data_presence_if_decrypted CHECK ((is_decrypted = False AND (dec_data_bytes IS NULL AND dec_data_object_id IS NULL)) OR (is_decrypted = True AND (dec_data_bytes IS NOT NULL OR dec_data_object_id IS NOT NULL))), 
            CONSTRAINT dpapi_blobs_check_enc_dec_data_consistency CHECK ((is_file = False AND enc_data_bytes IS NOT NULL AND enc_data_object_id IS NULL AND dec_data_object_id IS NULL) OR (is_file = True AND enc_data_bytes IS NULL AND enc_data_object_id IS NOT NULL AND dec_data_bytes IS NULL)), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE dpapi_blobs IS 'Contains extracted DPAPI blobs in their encrypted and/or decrypted forms.';

        COMMENT ON COLUMN dpapi_blobs.unique_db_id IS 'Unique row identifier for each DPAPI blob';

        COMMENT ON COLUMN dpapi_blobs.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN dpapi_blobs.dpapi_blob_id IS 'Nemesis-assigned unique identifier for the DPAPI blob';

        COMMENT ON COLUMN dpapi_blobs.originating_object_id IS 'Nemesis UUID referencing the original file the dpapi blob was extracted from';

        COMMENT ON COLUMN dpapi_blobs.originating_registry_id IS 'Nemesis UUID referencing the registry key the dpapi blob was extracted from';

        COMMENT ON COLUMN dpapi_blobs.masterkey_guid IS 'GUID of the masterkey associated with the DPAPI blob';

        COMMENT ON COLUMN dpapi_blobs.is_file IS 'Is the DPAPI blob associated with a Nemesis file UUID? If true, the extracted DPAPI blob too big to be stored as bytes in the DB and instead is stored as a file within Nemesis.';

        COMMENT ON COLUMN dpapi_blobs.is_decrypted IS 'Is the DPAPI blob decrypted?';

        COMMENT ON COLUMN dpapi_blobs.enc_data_bytes IS 'Bytes of the encrypted data (if less than 1024 bytes). Otherwise, use the enc_data_object_id column.';

        COMMENT ON COLUMN dpapi_blobs.enc_data_object_id IS 'If the encrypted data is > 1024 bytes, the Nemesis file UUID containing the encrypted data';

        COMMENT ON COLUMN dpapi_blobs.dec_data_bytes IS 'Decrypted DPAPI blob data (if less that 1024 bytes). Otherwise, the use the dec_data_object_id column';

        COMMENT ON COLUMN dpapi_blobs.dec_data_object_id IS 'If the decrypted data is > 1024 bytes, the Nemesis file UUID containing the decrytped data';

        COMMENT ON COLUMN dpapi_blobs.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN dpapi_blobs.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN dpapi_blobs.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN dpapi_blobs.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE dpapi_domain_backupkeys (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            domain_backupkey_guid UUID NOT NULL, 
            domain_controller TEXT NOT NULL, 
            domain_backupkey_bytes BYTEA NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (domain_backupkey_guid), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE dpapi_domain_backupkeys IS 'Contains extracted DPAPI domain backup keys.';

        COMMENT ON COLUMN dpapi_domain_backupkeys.unique_db_id IS 'Unique row identifier for each DPAPI blob';

        COMMENT ON COLUMN dpapi_domain_backupkeys.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN dpapi_domain_backupkeys.domain_backupkey_guid IS 'GUID of the domain backup key. Linked to dpapi_masterkeys.domain_backupkey_guid';

        COMMENT ON COLUMN dpapi_domain_backupkeys.domain_controller IS 'Domain controller from which the backup key was extracted';

        COMMENT ON COLUMN dpapi_domain_backupkeys.domain_backupkey_bytes IS 'Bytes of the domain''s DPAPI backup private key';

        COMMENT ON COLUMN dpapi_domain_backupkeys.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN dpapi_domain_backupkeys.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN dpapi_domain_backupkeys.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN dpapi_domain_backupkeys.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE dpapi_masterkeys (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            object_id UUID, 
            type TEXT, 
            username TEXT, 
            user_sid TEXT, 
            masterkey_guid UUID NOT NULL, 
            is_decrypted BOOLEAN, 
            masterkey_bytes BYTEA, 
            domain_backupkey_guid UUID, 
            domainkey_pb_secret BYTEA, 
            decrypted_key_full BYTEA, 
            decrypted_key_sha1 BYTEA, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (masterkey_guid), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE dpapi_masterkeys IS 'Contains individual extracted DPAPI master keys.';

        COMMENT ON COLUMN dpapi_masterkeys.unique_db_id IS 'Unique row identifier for each DPAPI blob';

        COMMENT ON COLUMN dpapi_masterkeys.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN dpapi_masterkeys.object_id IS 'Nemesis file UUID of the master key';

        COMMENT ON COLUMN dpapi_masterkeys.type IS 'Type of user the master key belongs to (domain_user, local_user, or machine)';

        COMMENT ON COLUMN dpapi_masterkeys.username IS 'Username of the user who owns the master key';

        COMMENT ON COLUMN dpapi_masterkeys.user_sid IS 'Security Identifier(SID) of the user who owns the master key';

        COMMENT ON COLUMN dpapi_masterkeys.masterkey_guid IS 'GUID of the master key. If a blob can be decrypted, dpapi_blobs.masterkey_guid should match this value.';

        COMMENT ON COLUMN dpapi_masterkeys.is_decrypted IS 'Is the master key decrypted?';

        COMMENT ON COLUMN dpapi_masterkeys.masterkey_bytes IS 'Bytes of the master key';

        COMMENT ON COLUMN dpapi_masterkeys.domain_backupkey_guid IS 'GUID of the domain backup key. Linked to dpapi_domain_backupkeys.domain_backupkey_guid';

        COMMENT ON COLUMN dpapi_masterkeys.domainkey_pb_secret IS 'Encrypted master key. Associated domain backup key can decrypt this.';

        COMMENT ON COLUMN dpapi_masterkeys.decrypted_key_full IS 'Decrypted master key';

        COMMENT ON COLUMN dpapi_masterkeys.decrypted_key_sha1 IS 'SHA1 representation of the master key';

        COMMENT ON COLUMN dpapi_masterkeys.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN dpapi_masterkeys.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN dpapi_masterkeys.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN dpapi_masterkeys.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE extracted_hashes (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            hash_type TEXT, 
            hash_value TEXT NOT NULL, 
            hashcat_formatted_value TEXT, 
            jtr_formatted_value TEXT, 
            is_cracked BOOLEAN, 
            checked_against_top_passwords BOOLEAN, 
            is_submitted_to_cracker BOOLEAN, 
            cracker_submission_time TIMESTAMP WITH TIME ZONE, 
            cracker_cracked_time TIMESTAMP WITH TIME ZONE, 
            plaintext_value TEXT, 
            hash_value_md5_hash UUID GENERATED ALWAYS AS (MD5(hash_value)::uuid) STORED NOT NULL, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT extracted_hashes_unique_constraint UNIQUE (timestamp, originating_object_id, hash_value_md5_hash)
        );

        COMMENT ON TABLE extracted_hashes IS 'Extracted hashes from various sources (e.g., encrypted files/documents)';

        COMMENT ON COLUMN extracted_hashes.unique_db_id IS 'Unique identifier';

        COMMENT ON COLUMN extracted_hashes.originating_object_id IS 'Nemesis file UUID if the hash was carved from a file';

        COMMENT ON COLUMN extracted_hashes.hash_type IS 'Type of hash';

        COMMENT ON COLUMN extracted_hashes.hash_value IS 'Value of the extracted hash';

        COMMENT ON COLUMN extracted_hashes.hashcat_formatted_value IS 'Hashcat-formatted hash value';

        COMMENT ON COLUMN extracted_hashes.jtr_formatted_value IS 'JTR-formatted hash value';

        COMMENT ON COLUMN extracted_hashes.is_cracked IS 'True if the hash has been cracked';

        COMMENT ON COLUMN extracted_hashes.checked_against_top_passwords IS 'True if checked against top passwords';

        COMMENT ON COLUMN extracted_hashes.is_submitted_to_cracker IS 'True if submitted to a cracker';

        COMMENT ON COLUMN extracted_hashes.cracker_submission_time IS 'Time the hash was submitted to a cracker';

        COMMENT ON COLUMN extracted_hashes.cracker_cracked_time IS 'Time the hash was cracked';

        COMMENT ON COLUMN extracted_hashes.plaintext_value IS 'Plaintext value if the hash has been cracked';

        COMMENT ON COLUMN extracted_hashes.hash_value_md5_hash IS 'MD5 hash of the hash value. Used in the unique constraint due to hashes potentially being too long for constraints';

        COMMENT ON COLUMN extracted_hashes.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN extracted_hashes.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN extracted_hashes.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN extracted_hashes.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE hosts_deprecated (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            id SERIAL NOT NULL, 
            hostname TEXT NOT NULL, 
            description TEXT, 
            os_type TEXT, 
            windows_major_version NUMERIC(9, 1), 
            windows_build TEXT, 
            windows_release TEXT, 
            windows_domain TEXT, 
            linux_kernel_version TEXT, 
            linux_distributor TEXT, 
            linux_release TEXT, 
            agent_ids TEXT[], 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT hosts_unique_constraint UNIQUE (hostname)
        );

        COMMENT ON COLUMN hosts_deprecated.unique_db_id IS 'Unique identifier';

        COMMENT ON COLUMN hosts_deprecated.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN hosts_deprecated.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN hosts_deprecated.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN hosts_deprecated.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE slack_downloads (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID NOT NULL, 
            username TEXT, 
            workspace_id TEXT NOT NULL, 
            download_id TEXT NOT NULL, 
            team_id TEXT, 
            user_id TEXT, 
            url TEXT, 
            download_path TEXT, 
            download_state TEXT, 
            start_time TIMESTAMP WITH TIME ZONE, 
            end_time TIMESTAMP WITH TIME ZONE, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT slack_downloads_unique_constraint UNIQUE (source, agent_id, originating_object_id, workspace_id, download_id)
        );

        COMMENT ON TABLE slack_downloads IS 'Parsed downloads from a ''slack-downloads'' file or Seatbelt json';

        COMMENT ON COLUMN slack_downloads.unique_db_id IS 'Unique row identifier for each Slack download entry';

        COMMENT ON COLUMN slack_downloads.agent_id IS 'C2 identifier of the agent that collected the data';

        COMMENT ON COLUMN slack_downloads.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN slack_downloads.username IS 'Username extracted from file path, if applicable';

        COMMENT ON COLUMN slack_downloads.workspace_id IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.download_id IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.team_id IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.user_id IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.url IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.download_path IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.download_state IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.start_time IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.end_time IS 'Extracted from slack-downloads';

        COMMENT ON COLUMN slack_downloads.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN slack_downloads.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN slack_downloads.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN slack_downloads.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE slack_workspaces (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            originating_object_id UUID, 
            username TEXT, 
            workspace_id TEXT, 
            workspace_domain TEXT, 
            workspace_name TEXT, 
            workspace_icon_url TEXT, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT slack_workspaces_unique_constraint UNIQUE (source, agent_id, originating_object_id, workspace_id, workspace_domain, workspace_name)
        );

        COMMENT ON TABLE slack_workspaces IS 'Parsed workspaces from a ''slack-workspaces'' file or Seatbelt json';

        COMMENT ON COLUMN slack_workspaces.unique_db_id IS 'Unique row identifier for each Slack download entry';

        COMMENT ON COLUMN slack_workspaces.agent_id IS 'C2 identifier of the agent that collected the data';

        COMMENT ON COLUMN slack_workspaces.originating_object_id IS 'Nemesis file UUID if this entry originated from a file';

        COMMENT ON COLUMN slack_workspaces.username IS 'Username extracted from file path, if applicable';

        COMMENT ON COLUMN slack_workspaces.workspace_id IS 'Extracted from slack-workspaces';

        COMMENT ON COLUMN slack_workspaces.workspace_domain IS 'Extracted from slack-workspaces';

        COMMENT ON COLUMN slack_workspaces.workspace_name IS 'Extracted from slack-workspaces';

        COMMENT ON COLUMN slack_workspaces.workspace_icon_url IS 'Extracted from slack-workspaces';

        COMMENT ON COLUMN slack_workspaces.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN slack_workspaces.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN slack_workspaces.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN slack_workspaces.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TABLE agents (
            id UUID DEFAULT gen_random_uuid() NOT NULL, 
            project_id UUID NOT NULL, 
            agent_id TEXT NOT NULL, 
            agent_type TEXT NOT NULL, 
            host_mapping_id UUID NOT NULL, 
            PRIMARY KEY (id), 
            FOREIGN KEY(host_mapping_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT agents_agent_id_agent_type_project_id_key UNIQUE (agent_id, agent_type, project_id), 
            UNIQUE (host_mapping_id), 
            UNIQUE (id)
        );

        COMMENT ON TABLE agents IS 'Basic information surfaced about collection agents that have submitted data';

        COMMENT ON COLUMN agents.id IS 'Unique row identifier for each agent';

        COMMENT ON COLUMN agents.project_id IS 'Project associated with the agent';

        COMMENT ON COLUMN agents.agent_id IS 'C2 identifier of the agent that collected the data (beacon: 12345, mythic: <GUID>, etc.)';

        COMMENT ON COLUMN agents.agent_type IS 'String describing the type of agent (beacon, apollo, stage1, etc.)';

        COMMENT ON COLUMN agents.host_mapping_id IS 'Points to the host mapping for agent. For each agent, there is a single agent_host_mappings row that maps it to a host (i.e., there is a 1:1 relationship between agents and agent host mappings)';

        CREATE TABLE agents_deprecated (
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            agent_id TEXT NOT NULL, 
            host_id INTEGER, 
            agent_type TEXT NOT NULL, 
            first_seen TIMESTAMP WITH TIME ZONE, 
            last_seen TIMESTAMP WITH TIME ZONE, 
            is_alive BOOLEAN, 
            arch TEXT, 
            process_name TEXT, 
            process_id INTEGER, 
            process_username TEXT, 
            project_id UUID NOT NULL, 
            source TEXT NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            PRIMARY KEY (agent_id), 
            FOREIGN KEY(host_id) REFERENCES hosts_deprecated (id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            CONSTRAINT agents_unique_constraint UNIQUE (agent_id, agent_type)
        );

        COMMENT ON TABLE agents_deprecated IS 'Tracks agents that have connected to the server';

        COMMENT ON COLUMN agents_deprecated.unique_db_id IS 'Unique identifier';

        COMMENT ON COLUMN agents_deprecated.agent_id IS 'ID from Cobalt Strike/Mythic/etc.';

        COMMENT ON COLUMN agents_deprecated.host_id IS 'Reference to host the agent is running on';

        COMMENT ON COLUMN agents_deprecated.agent_type IS 'Type of the agent';

        COMMENT ON COLUMN agents_deprecated.first_seen IS 'Timestamp when the agent was first seen';

        COMMENT ON COLUMN agents_deprecated.last_seen IS 'Timestamp when the agent was last seen';

        COMMENT ON COLUMN agents_deprecated.is_alive IS 'True if the agent is currently alive';

        COMMENT ON COLUMN agents_deprecated.arch IS 'Architecture of the agent''s system';

        COMMENT ON COLUMN agents_deprecated.process_name IS 'Name of the process the agent is running as';

        COMMENT ON COLUMN agents_deprecated.process_id IS 'Process ID of the agent process';

        COMMENT ON COLUMN agents_deprecated.process_username IS 'Username under which the agent process is running';

        COMMENT ON COLUMN agents_deprecated.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN agents_deprecated.source IS 'Source of the data. Value depends on the type of data collection. e.g., for host data, this is the hostname.';

        COMMENT ON COLUMN agents_deprecated.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN agents_deprecated.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        CREATE TYPE dataoperation AS ENUM ('list', 'add', 'remove');

        CREATE TABLE file_data_enriched (
            object_id UUID NOT NULL, 
            path TEXT NOT NULL, 
            name TEXT, 
            size BIGINT, 
            md5 TEXT, 
            sha1 TEXT, 
            sha256 TEXT, 
            nemesis_file_type TEXT, 
            magic_type TEXT, 
            converted_pdf_id UUID, 
            extracted_plaintext_id UUID, 
            extracted_source_id UUID, 
            tags TEXT[], 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id), 
            UNIQUE (object_id)
        );

        COMMENT ON TABLE file_data_enriched IS 'An in-between the Elastic and Postgres representations for enriched data. This is for ease of use of searching/filtering through the dashboard(s)';

        COMMENT ON COLUMN file_data_enriched.object_id IS 'Nemesis file UUID of the file';

        COMMENT ON COLUMN file_data_enriched.path IS 'The file''s path';

        COMMENT ON COLUMN file_data_enriched.name IS 'The file''s name';

        COMMENT ON COLUMN file_data_enriched.size IS 'Size of the file in bytes';

        COMMENT ON COLUMN file_data_enriched.md5 IS 'MD5 hash of the file';

        COMMENT ON COLUMN file_data_enriched.sha1 IS 'SHA1 hash of the file';

        COMMENT ON COLUMN file_data_enriched.sha256 IS 'SHA256 hash of the file';

        COMMENT ON COLUMN file_data_enriched.nemesis_file_type IS 'Nemesis-derived file type';

        COMMENT ON COLUMN file_data_enriched.magic_type IS 'Magic type of the file (derived from sniffing the file''s content via libmagic)';

        COMMENT ON COLUMN file_data_enriched.converted_pdf_id IS 'Nemesis file UUID if there''s a converted PDF linked to this file';

        COMMENT ON COLUMN file_data_enriched.extracted_plaintext_id IS 'Nemesis file UUID if there''s extracted plaintext linked to this file';

        COMMENT ON COLUMN file_data_enriched.extracted_source_id IS 'Nemesis file UUID if there''s extracted source code linked to this file';

        COMMENT ON COLUMN file_data_enriched.tags IS 'List of tags associated with the file (e.g., hash_dpapi, has_deserialization, etc.)';

        COMMENT ON COLUMN file_data_enriched.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN file_data_enriched.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN file_data_enriched.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN file_data_enriched.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN file_data_enriched.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN file_data_enriched.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN file_data_enriched.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN file_data_enriched.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN file_data_enriched.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        CREATE TYPE filesystemobjecttype AS ENUM ('file', 'folder');

        CREATE TABLE filesystem_objects (
            path TEXT NOT NULL, 
            name TEXT, 
            extension TEXT, 
            type filesystemobjecttype NOT NULL, 
            size INTEGER, 
            magic_type TEXT, 
            creation_time TIMESTAMP WITHOUT TIME ZONE, 
            access_time TIMESTAMP WITHOUT TIME ZONE, 
            modification_time TIMESTAMP WITHOUT TIME ZONE, 
            access_mode INTEGER, 
            file_group TEXT, 
            file_id TEXT, 
            owner TEXT, 
            sddl TEXT, 
            nemesis_file_id UUID, 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE filesystem_objects IS 'Filesystem objects (files and folders) collected from a host, whether through downloads or listings.';

        COMMENT ON COLUMN filesystem_objects.path IS 'Path to the file or folder';

        COMMENT ON COLUMN filesystem_objects.name IS 'Name of the file or folder';

        COMMENT ON COLUMN filesystem_objects.extension IS 'File extension';

        COMMENT ON COLUMN filesystem_objects.type IS 'Type of object: file or folder';

        COMMENT ON COLUMN filesystem_objects.size IS 'Size of the file in bytes';

        COMMENT ON COLUMN filesystem_objects.magic_type IS 'Type of the file (derived from sniffing the file''s content)';

        COMMENT ON COLUMN filesystem_objects.creation_time IS 'Time the file was created';

        COMMENT ON COLUMN filesystem_objects.access_time IS 'Time the file was last accessed';

        COMMENT ON COLUMN filesystem_objects.modification_time IS 'Time the file was last modified';

        COMMENT ON COLUMN filesystem_objects.access_mode IS 'File access mode (*nix permission number)';

        COMMENT ON COLUMN filesystem_objects.file_group IS 'File group (*nix case sensitive file group membership)';

        COMMENT ON COLUMN filesystem_objects.file_id IS 'File ID (*nix string for an inode or file id)';

        COMMENT ON COLUMN filesystem_objects.owner IS 'Case sensitive owner (*nix and Windows)';

        COMMENT ON COLUMN filesystem_objects.sddl IS 'Security Descriptor Definition Language (SDDL) string';

        COMMENT ON COLUMN filesystem_objects.nemesis_file_id IS 'Nemesis-assigned unique identifier for the file';

        COMMENT ON COLUMN filesystem_objects.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN filesystem_objects.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN filesystem_objects.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN filesystem_objects.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN filesystem_objects.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN filesystem_objects.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN filesystem_objects.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN filesystem_objects.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN filesystem_objects.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        CREATE INDEX filesystem_objects_on_path_idx ON filesystem_objects USING gin (path gin_trgm_ops);

        CREATE TABLE named_pipes (
            name TEXT NOT NULL, 
            server_process_id INTEGER, 
            server_process_name TEXT, 
            server_process_path TEXT, 
            server_process_session_id INTEGER, 
            sddl TEXT, 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE named_pipes IS 'Windows named pipes, derived Seatbelt data or submitted manually';

        COMMENT ON COLUMN named_pipes.name IS 'The pipe''s name';

        COMMENT ON COLUMN named_pipes.server_process_id IS 'Process ID that created the pipe';

        COMMENT ON COLUMN named_pipes.server_process_name IS 'Name of the process that created the pipe';

        COMMENT ON COLUMN named_pipes.server_process_path IS 'Full path to the process that created the pipe';

        COMMENT ON COLUMN named_pipes.server_process_session_id IS 'Session ID of the process that created the pipe';

        COMMENT ON COLUMN named_pipes.sddl IS 'Security Descriptor Definition Language (SDDL) string for the pipe';

        COMMENT ON COLUMN named_pipes.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN named_pipes.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN named_pipes.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN named_pipes.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN named_pipes.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN named_pipes.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN named_pipes.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN named_pipes.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN named_pipes.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        CREATE TABLE processes (
            name TEXT, 
            command_line TEXT, 
            file_name TEXT, 
            process_id INTEGER, 
            parent_process_id INTEGER, 
            architecture TEXT, 
            username TEXT, 
            category TEXT, 
            description TEXT, 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            CHECK ((name IS NOT NULL AND name <> '') OR process_id IS NOT NULL), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE processes IS 'Represents a process running on a host. At a minimum, a process needs a name and/or process ID.';

        COMMENT ON COLUMN processes.name IS 'The process''s name';

        COMMENT ON COLUMN processes.command_line IS 'A process''s command line';

        COMMENT ON COLUMN processes.file_name IS 'Path to the file';

        COMMENT ON COLUMN processes.process_id IS 'Process ID';

        COMMENT ON COLUMN processes.parent_process_id IS 'Parent process''s PID';

        COMMENT ON COLUMN processes.architecture IS 'Process''s architecture';

        COMMENT ON COLUMN processes.username IS 'The process''s username';

        COMMENT ON COLUMN processes.category IS 'Enriched category of the process';

        COMMENT ON COLUMN processes.description IS 'Enriched category''s description';

        COMMENT ON COLUMN processes.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN processes.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN processes.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN processes.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN processes.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN processes.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN processes.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN processes.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN processes.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        CREATE TABLE registry_objects (
            key TEXT NOT NULL, 
            value_name TEXT, 
            value_kind INTEGER, 
            value TEXT, 
            sddl TEXT, 
            tags TEXT, 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE registry_objects IS 'Registry entry objects';

        COMMENT ON COLUMN registry_objects.key IS 'Registry key';

        COMMENT ON COLUMN registry_objects.value_name IS 'Name of the registry value';

        COMMENT ON COLUMN registry_objects.value_kind IS 'The registry value''s data type';

        COMMENT ON COLUMN registry_objects.value IS 'Content of the registry value';

        COMMENT ON COLUMN registry_objects.sddl IS 'Security Descriptor Definition Language (SDDL) string for the registry object';

        COMMENT ON COLUMN registry_objects.tags IS 'Tags associated with the registry object';

        COMMENT ON COLUMN registry_objects.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN registry_objects.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN registry_objects.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN registry_objects.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN registry_objects.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN registry_objects.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN registry_objects.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN registry_objects.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN registry_objects.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        CREATE TABLE services (
            binary_path TEXT, 
            command_line TEXT, 
            description TEXT, 
            display_name TEXT, 
            name TEXT NOT NULL, 
            sddl TEXT, 
            service_dll_entrypoint TEXT, 
            service_dll_path TEXT, 
            service_type SMALLINT, 
            start_type SMALLINT, 
            state SMALLINT, 
            username TEXT, 
            filesystem_object_id UUID, 
            host_id UUID NOT NULL, 
            is_data_remote BOOLEAN NOT NULL, 
            operation dataoperation NOT NULL, 
            unique_db_id UUID DEFAULT gen_random_uuid() NOT NULL, 
            message_id UUID NOT NULL, 
            project_id UUID NOT NULL, 
            timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL, 
            expiration DATE NOT NULL, 
            agent_id UUID NOT NULL, 
            originating_object_id UUID, 
            PRIMARY KEY (unique_db_id), 
            FOREIGN KEY(agent_id) REFERENCES agents (id), 
            FOREIGN KEY(filesystem_object_id) REFERENCES filesystem_objects (unique_db_id), 
            FOREIGN KEY(host_id) REFERENCES agent_host_mappings (id), 
            FOREIGN KEY(message_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(originating_object_id) REFERENCES api_data_messages (message_id), 
            FOREIGN KEY(project_id) REFERENCES projects (id)
        );

        COMMENT ON TABLE services IS 'Windows services, derived from registry values or submitted manually';

        COMMENT ON COLUMN services.binary_path IS 'Filesystem path to the service''s binary';

        COMMENT ON COLUMN services.command_line IS 'Command line used to start the service';

        COMMENT ON COLUMN services.description IS 'Description of the service';

        COMMENT ON COLUMN services.display_name IS 'Display name of the service';

        COMMENT ON COLUMN services.name IS 'Name of the service';

        COMMENT ON COLUMN services.sddl IS 'Security Descriptor Definition Language (SDDL) string for the service';

        COMMENT ON COLUMN services.service_dll_entrypoint IS 'Entrypoint function name in the service DLL';

        COMMENT ON COLUMN services.service_dll_path IS 'Filesystem path to the service DLL';

        COMMENT ON COLUMN services.service_type IS 'Type of the service';

        COMMENT ON COLUMN services.start_type IS 'How the service starts';

        COMMENT ON COLUMN services.state IS 'Current state of the service';

        COMMENT ON COLUMN services.username IS 'Username under which the service runs';

        COMMENT ON COLUMN services.filesystem_object_id IS 'Reference to the service file if it''s been downloaded';

        COMMENT ON COLUMN services.host_id IS 'Identifies the host the data is currently mapped to';

        COMMENT ON COLUMN services.is_data_remote IS 'Is the data for a remote host? Or was it enumerated locally on the current machine?';

        COMMENT ON COLUMN services.operation IS 'Type of operation: list, add, or remove';

        COMMENT ON COLUMN services.message_id IS 'Original message ID assigned during data ingestion';

        COMMENT ON COLUMN services.project_id IS 'Project associated with the data';

        COMMENT ON COLUMN services.timestamp IS 'Timestamp of when the data was created/collected.';

        COMMENT ON COLUMN services.expiration IS 'Date when in the data expires. Format: YYYY-MM-DD';

        COMMENT ON COLUMN services.agent_id IS 'ID of the agent that collected the data';

        COMMENT ON COLUMN services.originating_object_id IS 'Message ID of the object that the data originated from. For example, registry keys originating from a registry hive file, or credentials originating from a file.';

        INSERT INTO alembic_version (version_num) VALUES ('e28785c94ca5') RETURNING alembic_version.version_num;






        -- Stored Procedures
        CREATE OR REPLACE FUNCTION f_register_agent_host(
            _project_id UUID,
            _message_timestamp TIMESTAMP,
            _expiration_date TIMESTAMP,
            _agent_id TEXT,
            _agent_type TEXT,
            _short_name TEXT,
            _long_name TEXT,
            _ip_address INET,
            OUT _host_id UUID,
            OUT _agent_row_id UUID
        )
        LANGUAGE plpgsql AS
        $func$
        BEGIN
            -- Check if the agent already already exists
            IF EXISTS (SELECT host_mapping_id, agent_id FROM agents WHERE project_id = _project_id AND agent_id = _agent_id AND agent_type = _agent_type) THEN
                -- RETURN (SELECT hostagents_row_id FROM agents WHERE project_id = _project_id AND agent_id = _agent_id AND agent_type = _agent_type);
                SELECT host_mapping_id, id FROM agents WHERE project_id = _project_id AND agent_id = _agent_id AND agent_type = _agent_type INTO _host_id, _agent_row_id;
            ELSE
                -- Agent doesn't exist, so create new host and agent
                INSERT INTO nemesis.agent_host_mappings (project_id, shortname, longname, ip_address)
                VALUES (_project_id, _short_name, _long_name, _ip_address)
                RETURNING id
                INTO _host_id;

                -- Typically bad idea to have this DO UPDATE on conflict, but should happen rarely
                -- See why at https://stackoverflow.com/a/42217872
                INSERT INTO agents (agent_id, agent_type, host_mapping_id, project_id)
                VALUES (_agent_id, _agent_type, _host_id, _project_id)
                ON CONFLICT (agent_id, agent_type, project_id)
                DO UPDATE SET agent_id=_agent_id
                RETURNING id
                INTO _agent_row_id;

                -- Return the new person ID
                -- RETURN _host_id;
            END IF;
        END;
        $func$;


        -- Creates a project (if it doesn't exist) safely during concurrency
        -- For reasons why and what this was derived from, see https://dba.stackexchange.com/questions/212580/concurrent-transactions-result-in-race-condition-with-unique-constraint-on-inser
        CREATE OR REPLACE FUNCTION f_register_project(_name text, _creation_timestamp TIMESTAMP, _expiration_date TIMESTAMP) RETURNS UUID
        LANGUAGE plpgsql AS
        $func$
        DECLARE
            _project_id UUID;
        BEGIN
            LOOP
                SELECT id
                FROM   projects
                WHERE  name = _name
                FOR    UPDATE
                INTO   _project_id;

                EXIT WHEN FOUND;

                INSERT INTO projects  AS a (name, timestamp, expiration)
                VALUES (_name, _creation_timestamp, _expiration_date)
                ON     CONFLICT (name) DO NOTHING  -- (new?) _content is discarded
                RETURNING a.id
                INTO   _project_id;

                EXIT WHEN FOUND;
            END LOOP;

            RETURN _project_id;
        END
        $func$;


        COMMIT;
